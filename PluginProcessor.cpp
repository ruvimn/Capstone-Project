/*
==============================================================================
	This class structure was generated by JUCE.
==============================================================================
*/

#include "PluginProcessor.h"
#include "PluginEditor.h"
#include "DistortionEffect.h"

//==============================================================================
DistortionEffectAudioProcessor::DistortionEffectAudioProcessor()
{
	//Initialize the plugin code.
	mDistortionEffect = DistortionEffect();

	//Default starting values of parameters
	userParams[inGain] = 1.0f; //unity gain
	userParams[outGain] = 1.0f; //unity gain
	userParams[drive] = 1.0f; //unity gain
	userParams[clip] = 0.0f; //hard clip
	setParameter(inGain, userParams[inGain]);
	setParameter(outGain, userParams[outGain]);
	setParameter(drive, userParams[drive]);
	setParameter(clip, userParams[clip]);
}

DistortionEffectAudioProcessor::~DistortionEffectAudioProcessor()
{
}

//==============================================================================
const String DistortionEffectAudioProcessor::getName() const
{
	return JucePlugin_Name;
}

int DistortionEffectAudioProcessor::getNumParameters()
{
	return totalNumParams;
}

float DistortionEffectAudioProcessor::getParameter(int index)
{
	switch (index) {
	//case bypass:
	//	return userParams[bypass];
	case inGain:
		userParams[inGain] = mDistortionEffect.getInputGain();
		return userParams[inGain];
	case outGain:
		userParams[outGain] = mDistortionEffect.getOutputGain();
		return userParams[outGain];
	case drive:
		userParams[drive] = mDistortionEffect.getDrive();
		return userParams[drive];
	case clip:
		return userParams[clip];
	default:
		return 0.0f;
	}
}

void DistortionEffectAudioProcessor::setParameter(int index, float newValue)
{
	switch (index) {
		case inGain:
			if (newValue < 0.0f) {
				userParams[inGain] = 0.0f;
				mDistortionEffect.setInputGain(userParams[inGain]);
				break;
			}
			else {
				userParams[inGain] = newValue;
				mDistortionEffect.setInputGain(userParams[inGain]);
				break;
			}
		case outGain:
			if (newValue < 0.0f) {
				userParams[outGain] = 0.0f;
				mDistortionEffect.setOutputGain(userParams[outGain]);
				break;
			}
			else {
				userParams[outGain] = newValue;
				mDistortionEffect.setOutputGain(userParams[outGain]);
				break;
			}
		case drive:
			userParams[drive] = newValue;
			mDistortionEffect.setDrive(userParams[drive]);
			break;
		case clip:
			if (newValue > 0.0f) {
				userParams[clip] = 1.0f;
			}
			else {
				userParams[clip] = 0.0f;
			}
			break;
		default:
			return; //Return before requesting a UI update; we don't need one.
	}
	RequestUIUpdate();
}

const String DistortionEffectAudioProcessor::getParameterName(int index)
{
	switch (index) {
	case inGain:
		return "Input Gain";
	case outGain:
		return "Output Gain";
	case drive:
		return "Drive";
	case clip:
		return "Clipping Style";
	default:
		return String::empty;
	}
}

const String DistortionEffectAudioProcessor::getParameterText(int index)
{
	if (index >= 0 && index < totalNumParams) {
		return String(userParams[index]); //Convert the value of the parameter to a string and return it.
	}
	else {
		return String::empty;
	}
}

const String DistortionEffectAudioProcessor::getInputChannelName(int channelIndex) const
{
	return String(channelIndex + 1);
}

const String DistortionEffectAudioProcessor::getOutputChannelName(int channelIndex) const
{
	return String(channelIndex + 1);
}

bool DistortionEffectAudioProcessor::isInputChannelStereoPair(int index) const
{
	return true;
}

bool DistortionEffectAudioProcessor::isOutputChannelStereoPair(int index) const
{
	return true;
}

bool DistortionEffectAudioProcessor::acceptsMidi() const
{
#if JucePlugin_WantsMidiInput
	return true;
#else
	return false;
#endif
}

bool DistortionEffectAudioProcessor::producesMidi() const
{
#if JucePlugin_ProducesMidiOutput
	return true;
#else
	return false;
#endif
}

bool DistortionEffectAudioProcessor::silenceInProducesSilenceOut() const
{
	return false;
}

double DistortionEffectAudioProcessor::getTailLengthSeconds() const
{
	return 0.0;
}

int DistortionEffectAudioProcessor::getNumPrograms()
{
	return 1;   // NB: some hosts don't cope very well if you tell them there are 0 programs,
				// so this should be at least 1, even if you're not really implementing programs.
}

int DistortionEffectAudioProcessor::getCurrentProgram()
{
	return 0;
}

void DistortionEffectAudioProcessor::setCurrentProgram(int index)
{
}

const String DistortionEffectAudioProcessor::getProgramName(int index)
{
	return String();
}

void DistortionEffectAudioProcessor::changeProgramName(int index, const String& newName)
{
}

//==============================================================================
void DistortionEffectAudioProcessor::prepareToPlay(double sampleRate, int samplesPerBlock)
{
	// Use this method as the place to do any pre-playback
	// initialisation that you need..
}

void DistortionEffectAudioProcessor::releaseResources()
{
	// When playback stops, you can use this as an opportunity to free up any
	// spare memory, etc.
}

void DistortionEffectAudioProcessor::processBlock(AudioSampleBuffer& buffer, MidiBuffer& midiMessages)
{
	// This is where all the digital signal processing is done

	for (int i = getNumInputChannels(); i < getNumOutputChannels(); ++i) 
		buffer.clear(i, 0, buffer.getNumSamples());

	if (getNumInputChannels() == 2) {

		float *leftBuffer = buffer.getWritePointer(0);
		float *rightBuffer = buffer.getWritePointer(1);
		long i;
		int j;
		//DSP applied as follows: 
		// 1) Input gain
		// 2) Hardclip or Softknee (user determines which)
		// 3) Output gain 

		for (i = 0; i < buffer.getNumSamples(); ++i) {
			// Input gain
			mDistortionEffect.applyInputGain(&leftBuffer[i], &rightBuffer[i]);

			// Hardclip or softknee
			if (getParameter(clip) == 0.0f) {
				mDistortionEffect.hardClip(&leftBuffer[i], &rightBuffer[i]);
			}
			else if (getParameter(clip) == 1.0f) {
				mDistortionEffect.softClip(&leftBuffer[i], &rightBuffer[i]);
			}

			// Output
			mDistortionEffect.applyOutputGain(&leftBuffer[i], &rightBuffer[i]);
		}
	}
}

//==============================================================================
bool DistortionEffectAudioProcessor::hasEditor() const
{
	return true; // (change this to false if you choose to not supply an editor)
}

AudioProcessorEditor* DistortionEffectAudioProcessor::createEditor()
{
	return new DistortionEffectAudioProcessorEditor(*this);
}

//==============================================================================
void DistortionEffectAudioProcessor::getStateInformation(MemoryBlock& destData)
{
	// Used to store information in the memory block
	XmlElement xml("DistortionEffectSETTINGS");

	//Set attributes.
	for (int i = 0; i < totalNumParams; ++i) {
		xml.setAttribute(getParameterName(i), getParameter(i));
	}

	//Dump to the given memory block.
	copyXmlToBinary(xml, destData);
}

void DistortionEffectAudioProcessor::setStateInformation(const void* data, int sizeInBytes)
{
	// Used to recall information from memory block

	ScopedPointer<XmlElement> xmlState(getXmlFromBinary(data, sizeInBytes));

	if (xmlState != nullptr) {
		if (xmlState->hasTagName("DistortionEffectSETTINGS")) {
			for (int i = 0; i < totalNumParams; ++i) {
				setParameter(i, (float)xmlState->getDoubleAttribute(getParameterName(i), getParameter(i)));
			}
		}
	}

	RequestUIUpdate();
}

//==============================================================================
// This creates new instances of the plugin..
AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
	return new DistortionEffectAudioProcessor();
}